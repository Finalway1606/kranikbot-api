import irc.client
import threading
import time
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import random
import sys
import os
import asyncio
from dotenv import load_dotenv
import requests
import json
from datetime import datetime, timedelta

# Konfiguracja kodowania dla Windows
if sys.platform == "win32":
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

def safe_print(text):
    """Bezpieczne drukowanie z obs≈ÇugƒÖ emoji na Windows"""
    try:
        print(text, flush=True)
    except UnicodeEncodeError:
        # Zamie≈Ñ emoji na tekst je≈õli nie mo≈ºna ich wy≈õwietliƒá
        safe_text = text.encode('ascii', 'replace').decode('ascii')
        print(safe_text, flush=True)
    except Exception as e:
        # Fallback - wydrukuj bez emoji
        try:
            clean_text = ''.join(char for char in text if ord(char) < 128)
            print(f"[LOG] {clean_text}", flush=True)
        except:
            print(f"[LOG] Message encoding error", flush=True)

from reminders import ZBIORKA_MSG, DISCORD_MSG, FOLLOW_MSG, PRIME_MSG, BITS_MSG
from motywacja import MOTYWACYJNE_CYTATY
from database import UserDatabase
from games import MiniGames
from shop import Shop
from discord_integration import DiscordIntegration
from discord_bot import DiscordBot

# ≈Åadowanie zmiennych ≈õrodowiskowych
load_dotenv()

# === KONFIGURACJA FOLLOW√ìW ===
FOLLOW_THANKS_ENABLED = True
FOLLOW_THANKS_MESSAGES = [
    "üéâ Dziƒôkujƒô za follow, @{username}! Mi≈Ço Ciƒô widzieƒá w spo≈Çeczno≈õci! üíú",
    "üíú Witaj w rodzinie, @{username}! Dziƒôki za follow! üéâ",
    "üî• @{username} do≈ÇƒÖczy≈Ç do nas! Dziƒôkujƒô za follow! üíú",
    "‚ú® Nowy follower! Witaj @{username}, dziƒôkujƒô za wsparcie! üéâ",
    "üéä @{username} w≈Ça≈õnie nas obserwuje! Dziƒôki za follow! üíú"
]

# === KONFIGURACJA SUBSKRYPCJI ===
SUB_THANKS_ENABLED = True
SUB_THANKS_MESSAGES = [
    "üåü DZIƒòKUJƒò ZA SUB, @{username}! Jeste≈õ niesamowity! üíú‚ú®",
    "üéä @{username} w≈Ça≈õnie zasubskrybowa≈Ç! OGROMNE DZIƒòKI! üî•üíú",
    "üíé SUB od @{username}! To znaczy dla mnie bardzo wiele! üôèüíú",
    "üöÄ @{username} do≈ÇƒÖczy≈Ç do sub√≥w! Jeste≈õ wspania≈Çy! üéâüíú",
    "‚≠ê NOWY SUB! Dziƒôkujƒô @{username} za niesamowite wsparcie! üíúüéä"
]

# KONFIGURACJA TWITCH
TWITCH_SERVER = "irc.chat.twitch.tv"
TWITCH_PORT = 6667
NICKNAME = os.getenv("TWITCH_NICKNAME", "KranikBot")
TOKEN = os.getenv("TWITCH_TOKEN")
CHANNEL = os.getenv("TWITCH_CHANNEL")

# Dynamiczne listy uprawnie≈Ñ - bƒôdƒÖ pobierane z Twitch API
# Zamiast hardkodowanych list u≈ºywamy pustych set√≥w, kt√≥re bƒôdƒÖ wype≈Çniane automatycznie

SONG_REQUEST_TIMEOUT = int(os.getenv("SONG_REQUEST_TIMEOUT", "300"))

class TwitchBot:
    def __init__(self):
        # Sprawdzenie czy wszystkie wymagane zmienne sƒÖ ustawione
        if not TOKEN:
            raise ValueError("TWITCH_TOKEN nie jest ustawiony w pliku .env")
        if not CHANNEL:
            raise ValueError("TWITCH_CHANNEL nie jest ustawiony w pliku .env")
        
        # Inicjalizacja IRC po≈ÇƒÖczenia
        self.reactor = irc.client.Reactor()
        self.connection = self.reactor.server().connect(TWITCH_SERVER, TWITCH_PORT, NICKNAME, password=TOKEN)
        self.connection.add_global_handler("welcome", self.on_connect)
        self.connection.add_global_handler("pubmsg", self.on_message)
        self.connection.add_global_handler("usernotice", self.on_usernotice)

        # Spotify konfiguracja z zmiennych ≈õrodowiskowych
        spotify_client_id = os.getenv("SPOTIFY_CLIENT_ID")
        spotify_client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")
        spotify_redirect_uri = os.getenv("SPOTIFY_REDIRECT_URI", "http://127.0.0.1:8888/callback")
        
        # Zawsze inicjalizuj podstawowe atrybuty Spotify
        self.pending_song_requests = {}
        self.last_request_time = {}
        self.spotify_enabled = False
        self.sp = None
        self.token_info = None
        self.sp_oauth = None
        
        if not spotify_client_id or not spotify_client_secret:
            safe_print(f"‚ö†Ô∏è Brak konfiguracji Spotify - modu≈Ç bƒôdzie wy≈ÇƒÖczony")
        else:
            try:
                self.sp_oauth = SpotifyOAuth(
                    client_id=spotify_client_id,
                    client_secret=spotify_client_secret,
                    redirect_uri=spotify_redirect_uri,
                    scope="user-modify-playback-state user-read-playback-state",
                    open_browser=True
                )
                
                # Inicjalizacja Spotify z lepszƒÖ obs≈ÇugƒÖ token√≥w
                token_info = self.sp_oauth.get_cached_token()
                if token_info:
                    safe_print(f"‚úÖ Znaleziono zapisane tokeny Spotify")
                    self.token_info = token_info
                    self.sp = spotipy.Spotify(auth=token_info['access_token'])
                    self.spotify_enabled = True
                else:
                    safe_print(f"üîë Rozpoczynam autoryzacjƒô Spotify...")
                    safe_print(f"üì± Otworzƒô przeglƒÖdarkƒô - zaloguj siƒô i autoryzuj aplikacjƒô")
                    # U≈ºywamy get_cached_token zamiast deprecated get_access_token
                    auth_url = self.sp_oauth.get_authorize_url()
                    safe_print(f"üåê Je≈õli przeglƒÖdarka siƒô nie otworzy, id≈∫ na: {auth_url}")
                    
                    # Pobieramy token bez deprecated parametru
                    token_info = self.sp_oauth.get_access_token()
                    if token_info:
                        self.token_info = token_info
                        self.sp = spotipy.Spotify(auth=token_info['access_token'])
                        self.spotify_enabled = True
                        safe_print(f"‚úÖ Autoryzacja Spotify zako≈Ñczona pomy≈õlnie!")
                    else:
                        raise Exception("Nie uda≈Ço siƒô uzyskaƒá tokenu Spotify")
                        
            except Exception as e:
                safe_print(f"‚ùå B≈ÇƒÖd autoryzacji Spotify: {e}")
                safe_print(f"‚ö†Ô∏è Modu≈Ç Spotify bƒôdzie wy≈ÇƒÖczony")
                self.spotify_enabled = False
                self.sp = None
                self.token_info = None
        
        # Follow tracking
        self.follow_thanks_enabled = FOLLOW_THANKS_ENABLED
        self.last_followers = set()
        self.check_followers_thread = None
        
        # Subscription tracking
        self.sub_thanks_enabled = SUB_THANKS_ENABLED
        self.last_subscribers = set()
        self.check_subscribers_thread = None
        
        # Dynamiczne listy uprawnie≈Ñ
        self.moderators = set()
        self.vips = set()
        self.subscribers = set()
        self.trusted_users = {"kranik1606"}  # W≈Ça≈õciciel zawsze ma uprawnienia
        self.subs_no_limit = {"kranik1606"}  # W≈Ça≈õciciel zawsze ma unlimited
        self.allowed_skip = {"kranik1606"}   # W≈Ça≈õciciel zawsze mo≈ºe skipowaƒá
        
        # Sprawd≈∫ konfiguracjƒô Twitch API
        if not os.getenv('TWITCH_CLIENT_ID') or not os.getenv('TWITCH_ACCESS_TOKEN'):
            safe_print(f"‚ö†Ô∏è  Brak konfiguracji Twitch API - funkcje follow√≥w i sub√≥w wy≈ÇƒÖczone")
            safe_print(f"üìñ Zobacz plik TWITCH_API_SETUP.md dla instrukcji")
            self.follow_thanks_enabled = False
            self.sub_thanks_enabled = False
        else:
            # Uruchom pierwsze pobieranie uprawnie≈Ñ
            self.update_permissions_on_startup()
        
        # Uruchom sprawdzanie follow√≥w i sub√≥w
        if self.follow_thanks_enabled:
            self.start_follow_checker()
        if self.sub_thanks_enabled:
            self.start_subscription_checker()
        
        # Inicjalizacja systemu gier i bazy danych
        self.db = UserDatabase()
        self.games = MiniGames(self.db, self)
        self.shop = Shop(self.db)
        self.discord = DiscordIntegration()
        safe_print(f"üéÆ System gier i punkt√≥w zainicjalizowany!")
        safe_print(f"üõí Sklep nagr√≥d zainicjalizowany!")
        safe_print(f"üîó Integracja Discord zainicjalizowana!")
        
        # Inicjalizacja hash bez wysy≈Çania wiadomo≈õci na Discord
        self.discord.initialize_leaderboard_hash(self.db)
        self.shop.initialize_shop_hash()
        safe_print(f"üîß Zainicjalizowano hash rankingu i sklepu bez wysy≈Çania wiadomo≈õci")
        
        # Inicjalizacja Discord bot z slash commands
        self.discord_bot = DiscordBot(self.db, self.discord, self.shop)
        if self.discord_bot.start_bot():
            safe_print(f"ü§ñ Discord bot z slash commands uruchomiony!")
        else:
            safe_print(f"‚ö†Ô∏è Discord bot z slash commands nie zosta≈Ç uruchomiony")
        
        # Uruchom monitor statusu streama
        self.start_stream_monitor()
        
        # Uruchom dzienne statystyki Discord
        self.start_daily_stats()
        
        # Uruchom sprawdzanie timeout quizu
        self.start_quiz_timeout_checker()
        
        # Uruchom automatyczne aktualizacje Discord
        self.start_leaderboard_updater()
        
        # Uruchom monitor zmian w sklepie
        self.start_shop_monitor()

    def get_channel_name(self):
        """Zwraca poprawny format nazwy kana≈Çu z # na poczƒÖtku"""
        return CHANNEL if CHANNEL.startswith('#') else f"#{CHANNEL}"

    def ensure_token_valid(self):
        """Sprawdza i od≈õwie≈ºa token Spotify je≈õli to konieczne"""
        if not self.spotify_enabled or not self.token_info:
            return False
            
        try:
            if self.sp_oauth.is_token_expired(self.token_info):
                safe_print(f"üîÑ Od≈õwie≈ºam token Spotify...")
                self.token_info = self.sp_oauth.refresh_access_token(self.token_info['refresh_token'])
                self.sp = spotipy.Spotify(auth=self.token_info['access_token'])
                safe_print(f"‚úÖ Token Spotify od≈õwie≈ºony")
            return True
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd od≈õwie≈ºania tokenu Spotify: {e}")
            self.spotify_enabled = False
            return False

    def on_connect(self, connection, event):
        safe_print(f"‚úÖ Po≈ÇƒÖczono z Twitch IRC!")
        
        # Pobierz poprawny format nazwy kana≈Çu
        channel_name = self.get_channel_name()
        safe_print(f"üîó Pr√≥bujƒô do≈ÇƒÖczyƒá do kana≈Çu: {channel_name}")
        
        # ≈ªƒÖdaj capabilities aby otrzymywaƒá tagi z USERNOTICE
        connection.cap("REQ", ":twitch.tv/tags")
        connection.cap("REQ", ":twitch.tv/commands")
        connection.join(channel_name)
        
        safe_print(f"üìù Wysy≈Çam wiadomo≈õƒá powitalnƒÖ...")
        # Wy≈õlij wiadomo≈õƒá powitalnƒÖ
        connection.privmsg(channel_name, "Robocik wbija bez pytania ü§ñ")
        safe_print(f"‚úÖ Bot gotowy do pracy na kanale {channel_name}!")
        
        self.start_reminder()  # URUCHAMIAMY PRZYPOMNIENIA PO PO≈ÅƒÑCZENIU

    def on_message(self, connection, event):
        username = event.source.split("!")[0].lower()
        message = event.arguments[0].strip()
        channel_name = self.get_channel_name()
        
        # Ignoruj w≈Çasne wiadomo≈õci bota
        if username == "kranikbot":
            return
        
        # U≈ºywamy dynamicznych list uprawnie≈Ñ zamiast hardkodowanych

        # Sprawd≈∫ czy u≈ºytkownik jest followerem
        is_follower = self.is_follower(username)
        
        # Dodaj punkty tylko za pierwszƒÖ wiadomo≈õƒá (10 pkt) - tylko dla follower√≥w
        first_message_points = self.db.add_message(username, is_follower)
        if first_message_points > 0:
            connection.privmsg(channel_name, f"üéâ Witaj @{username}! Otrzymujesz {first_message_points} punkt√≥w za pierwszƒÖ wiadomo≈õƒá! Kolejne punkty zdobywasz grajƒÖc w minigry.")
        elif not is_follower and first_message_points == 0:
            # Sprawd≈∫ czy to nowy u≈ºytkownik bez follow
            user = self.db.get_user(username)
            if user and user[2] == 1:  # messages_count == 1 (pierwsza wiadomo≈õƒá)
                connection.privmsg(channel_name, f"üëã Witaj @{username}! Aby zdobywaƒá punkty, musisz zostaƒá followerem kana≈Çu!")
        
        # Sprawd≈∫ codzienny bonus - tylko dla follower√≥w
        if is_follower:
            bonus_msg = self.games.check_daily_bonus(username)
            if bonus_msg:
                connection.privmsg(channel_name, bonus_msg)

        # === KOMENDY GIER I PUNKT√ìW ===
        if message == "!roll":
            result = self.games.roll_dice(username)
            connection.privmsg(channel_name, result)
            return

        elif message.startswith("!coinflip"):
            parts = message.split()
            choice = parts[1] if len(parts) > 1 else None
            result = self.games.coin_flip(username, choice)
            connection.privmsg(channel_name, result)
            return

        elif message.startswith("!roulette "):
            bet = message[len("!roulette "):].strip()
            result = self.games.roulette(username, bet)
            connection.privmsg(channel_name, result)
            return

        elif message == "!quiz":
            result = self.games.start_quiz()
            connection.privmsg(channel_name, result)
            return

        elif message.startswith("!answer "):
            answer = message[len("!answer "):].strip()
            result = self.games.answer_quiz(username, answer)
            connection.privmsg(channel_name, result)
            return

        elif message == "!daily":
            is_follower = self.is_follower(username)
            if not is_follower:
                connection.privmsg(channel_name, f"‚ùå @{username}, musisz byƒá followerem kana≈Çu aby otrzymaƒá dzienny bonus!")
                return
                
            success, bonus = self.db.daily_bonus(username, is_follower)
            if success and bonus > 0:
                result = f"üéÅ @{username} otrzyma≈Ç dzienny bonus: +{bonus} punkt√≥w!"
            else:
                result = f"‚ùå @{username}, ju≈º odebra≈Çe≈õ dzienny bonus! Spr√≥buj jutro."
            connection.privmsg(channel_name, result)
            return

        elif message == "!points":
            result = self.games.get_user_stats(username)
            connection.privmsg(channel_name, result)
            return

        elif message == "!top":
            result = self.games.get_leaderboard()
            connection.privmsg(channel_name, result)
            return

        elif message.startswith("!give "):
            parts = message.split()
            if len(parts) >= 3:
                to_user = parts[1].lstrip('@')
                points = parts[2]
                is_mod = username in self.trusted_users
                result = self.games.give_points(username, to_user, points, is_mod)
                connection.privmsg(channel_name, result)
            else:
                connection.privmsg(channel_name, f"@{username}, u≈ºyj: !give @user <punkty>")
            return

        # === KOMENDY SKLEPU ===
        elif message == "!shop":
            result = self.shop.get_shop_list()
            connection.privmsg(channel_name, result)
            return

        elif message.startswith("!kup "):
            reward_id = message[len("!kup "):].strip()
            result = self.shop.buy_reward(username, reward_id)
            connection.privmsg(channel_name, result)
            return

        elif message == "!inventory":
            result = self.shop.get_user_inventory(username)
            connection.privmsg(channel_name, result)
            return

        elif message.startswith("!daj "):
            if username.lower() == "kranik1606":  # Tylko w≈Ça≈õciciel
                parts = message[len("!daj "):].strip().split()
                if len(parts) >= 2:
                    target_user = parts[0].lstrip('@')
                    reward_id = parts[1]
                    result = self.shop.give_reward_as_owner(target_user, reward_id)
                    connection.privmsg(channel_name, result)
                else:
                    connection.privmsg(channel_name, f"@{username}, u≈ºyj: !daj @user <nagroda>")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, tylko w≈Ça≈õciciel mo≈ºe dawaƒá nagrody za darmo.")
            return

        elif message.startswith("!zabierz "):
            # Sprawd≈∫ uprawnienia - tylko w≈Ça≈õciciel i moderatorzy
            is_owner = username.lower() == "kranik1606"
            is_mod = username in self.trusted_users
            
            if not (is_owner or is_mod):
                connection.privmsg(channel_name, f"‚ùå @{username}, brak uprawnie≈Ñ do zabierania nagr√≥d.")
                return
            
            parts = message.split()
            if len(parts) >= 3:
                target_user = parts[1].lstrip('@')
                reward_id = parts[2]
                result = self.shop.remove_reward(target_user, reward_id)
                connection.privmsg(channel_name, f"üî® @{username}: {result}")
            else:
                connection.privmsg(channel_name, f"@{username}, u≈ºyj: !zabierz @user <nagroda>")
            return

        elif message == "!resetall":
            if username.lower() == "kranik1606":  # Tylko w≈Ça≈õciciel
                # Resetuj wszystkie nagrody
                rewards_reset = self.shop.reset_all_rewards()
                # Resetuj wszystkie punkty
                points_reset = self.games.reset_all_points()
                
                connection.privmsg(channel_name, f"üî• @{username} zresetowa≈Ç WSZYSTKO! Usuniƒôto {rewards_reset} nagr√≥d i zresetowano punkty {points_reset} u≈ºytkownik√≥w.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, tylko w≈Ça≈õciciel mo≈ºe u≈ºyƒá tej komendy.")
            return

        # === KOMENDY SPOTIFY ===

        elif message == "!spotifyoff":
            if username in self.trusted_users:
                self.spotify_enabled = False
                connection.privmsg(channel_name, f"üîá @{username} wy≈ÇƒÖczy≈Ç modu≈Ç Spotify.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, brak uprawnie≈Ñ do wy≈ÇƒÖczenia Spotify.")
            return

        elif message == "!spotifyon":
            if username in self.trusted_users:
                self.spotify_enabled = True
                connection.privmsg(channel_name, f"üéµ @{username} ponownie w≈ÇƒÖczy≈Ç modu≈Ç Spotify.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, brak uprawnie≈Ñ do w≈ÇƒÖczenia Spotify.")
            return

        elif message.startswith("!sr "):
            if not self.spotify_enabled:
                connection.privmsg(channel_name, f"‚ùå @{username}, modu≈Ç Spotify jest obecnie wy≈ÇƒÖczony.")
                return

            now = time.time()
            last_time = self.last_request_time.get(username, 0)

            if username not in self.subs_no_limit:
                remaining = int(SONG_REQUEST_TIMEOUT - (now - last_time))
                if now - last_time < SONG_REQUEST_TIMEOUT:
                    minutes = remaining // 60
                    seconds = remaining % 60
                    connection.privmsg(channel_name, f"‚ùå @{username}, mo≈ºesz dodaƒá kolejnƒÖ piosenkƒô za {minutes}m {seconds}s.")
                    return

            song_name = message[len("!sr "):].strip()
            if not song_name:
                connection.privmsg(channel_name, f"@{username}, podaj tytu≈Ç piosenki po komendzie !sr")
                return

            try:
                if not self.ensure_token_valid():
                    connection.privmsg(channel_name, f"‚ùå @{username}, problem z autoryzacjƒÖ Spotify.")
                    return
                    
                results = self.sp.search(q=song_name, limit=3, type='track')
                tracks = results.get('tracks', {}).get('items', [])
                if not tracks:
                    connection.privmsg(channel_name, f"‚ùå @{username}, nie znalaz≈Çem ≈ºadnych wynik√≥w dla \"{song_name}\".")
                    return

                self.pending_song_requests[username] = tracks
                connection.privmsg(channel_name, f"@{username}, wybierz piosenkƒô wpisujƒÖc !select <numer>:")
                for i, track in enumerate(tracks, 1):
                    artists = ", ".join(artist['name'] for artist in track['artists'])
                    connection.privmsg(channel_name, f"{i}. {track['name']} - {artists}")

            except Exception as e:
                safe_print(f"Spotify error:", e)
                connection.privmsg(channel_name, f"‚ùå @{username}, wystƒÖpi≈Ç b≈ÇƒÖd podczas wyszukiwania piosenki.")

        elif message.startswith("!select "):
            if not self.spotify_enabled:
                connection.privmsg(channel_name, f"‚ùå @{username}, modu≈Ç Spotify jest obecnie wy≈ÇƒÖczony.")
                return

            if username not in self.pending_song_requests:
                connection.privmsg(channel_name, f"@{username}, nie masz ≈ºadnych oczekujƒÖcych propozycji.")
                return
            try:
                choice = int(message[len("!select "):].strip())
                tracks = self.pending_song_requests[username]
                if choice < 1 or choice > len(tracks):
                    connection.privmsg(channel_name, f"@{username}, wybierz numer od 1 do {len(tracks)}.")
                    return
                track = tracks[choice - 1]
                if not self.ensure_token_valid():
                    connection.privmsg(channel_name, f"‚ùå @{username}, problem z autoryzacjƒÖ Spotify.")
                    return
                    
                self.sp.add_to_queue(track['uri'])
                artists = ", ".join(artist['name'] for artist in track['artists'])
                connection.privmsg(channel_name, f"üé∂ @{username}, dodano: \"{track['name']}\" - {artists}")
                self.last_request_time[username] = time.time()
                del self.pending_song_requests[username]
            except Exception as e:
                safe_print(f"Spotify error:", e)
                connection.privmsg(channel_name, f"‚ùå @{username}, b≈ÇƒÖd przy dodawaniu piosenki.")

        elif message == "!ply":
            if not self.spotify_enabled:
                connection.privmsg(channel_name, f"‚ùå @{username}, modu≈Ç Spotify jest obecnie wy≈ÇƒÖczony.")
                return

            if not self.ensure_token_valid():
                connection.privmsg(channel_name, f"‚ùå @{username}, problem z autoryzacjƒÖ Spotify.")
                return
                
            if self.start_playback():
                connection.privmsg(channel_name, f"‚ñ∂Ô∏è @{username}, rozpoczƒÖ≈Çem odtwarzanie na Spotify!")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie uda≈Ço siƒô rozpoczƒÖƒá odtwarzania.")

        elif message == "!skip":
            if not self.spotify_enabled:
                connection.privmsg(channel_name, f"‚ùå @{username}, modu≈Ç Spotify jest obecnie wy≈ÇƒÖczony.")
                return

            if username not in self.allowed_skip:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do u≈ºycia tej komendy.")
                return
            try:
                if not self.ensure_token_valid():
                    connection.privmsg(channel_name, f"‚ùå @{username}, problem z autoryzacjƒÖ Spotify.")
                    return
                    
                self.sp.next_track()
                connection.privmsg(channel_name, f"‚è≠Ô∏è @{username} pominƒÖ≈Ç aktualnƒÖ piosenkƒô.")
            except Exception as e:
                safe_print(f"Spotify skip error:", e)
                connection.privmsg(channel_name, f"‚ùå @{username}, nie uda≈Ço siƒô pominƒÖƒá piosenki.")

        elif message == "!currentsong":
            if not self.spotify_enabled:
                connection.privmsg(channel_name, f"‚ùå @{username}, modu≈Ç Spotify jest obecnie wy≈ÇƒÖczony.")
                return

            try:
                if not self.ensure_token_valid():
                    connection.privmsg(channel_name, f"‚ùå @{username}, problem z autoryzacjƒÖ Spotify.")
                    return
                    
                playback = self.sp.current_playback()
                if playback and playback.get('item'):
                    track = playback['item']
                    artists = ", ".join(artist['name'] for artist in track['artists'])
                    connection.privmsg(channel_name, f"üéµ Teraz gra: \"{track['name']}\" - {artists}")
                else:
                    connection.privmsg(channel_name, "‚ùå Nie ma aktualnie odtwarzanej piosenki.")
            except Exception as e:
                safe_print(f"Spotify error:", e)
                connection.privmsg(channel_name, "‚ùå B≈ÇƒÖd przy pobieraniu informacji o piosence.")

        elif message == "!help":
            help_msg1 = (
                "üéµ Spotify: !sr <tytu≈Ç> | !select <numer> | !currentsong"
            )
            help_msg2 = (
                "üéÆ Gry: !roll | !coinflip <orze≈Ç/reszka> | !roulette <liczba/kolor> | !quiz | !answer <odpowied≈∫>"
            )
            help_msg3 = (
                "üí∞ Punkty: !points | !top | !daily | !give @user <punkty> | !motywacja"
            )
            help_msg4 = (
                "üõí Sklep: !shop | !kup <nagroda> | !inventory"
            )
            connection.privmsg(channel_name, help_msg1)
            connection.privmsg(channel_name, help_msg2)
            connection.privmsg(channel_name, help_msg3)
            connection.privmsg(channel_name, help_msg4)

        # === KOMENDY FOLLOW√ìW ===
        elif message == "!followsoff":
            if username in self.trusted_users:
                self.follow_thanks_enabled = False
                connection.privmsg(channel_name, f"üîá @{username} wy≈ÇƒÖczy≈Ç automatyczne dziƒôkowanie za followy.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, brak uprawnie≈Ñ do wy≈ÇƒÖczenia follow√≥w.")
            return

        elif message == "!followson":
            if username in self.trusted_users:
                if not os.getenv('TWITCH_CLIENT_ID') or not os.getenv('TWITCH_ACCESS_TOKEN'):
                    connection.privmsg(channel_name, f"‚ùå @{username}, brak konfiguracji Twitch API. Zobacz TWITCH_API_SETUP.md")
                    return
                    
                self.follow_thanks_enabled = True
                if not self.check_followers_thread or not self.check_followers_thread.is_alive():
                    self.start_follow_checker()
                connection.privmsg(channel_name, f"üíú @{username} w≈ÇƒÖczy≈Ç automatyczne dziƒôkowanie za followy.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, brak uprawnie≈Ñ do w≈ÇƒÖczenia follow√≥w.")
            return

        # === KOMENDY SUBSKRYPCJI ===
        elif message == "!subsoff":
            if username in self.trusted_users:
                self.sub_thanks_enabled = False
                connection.privmsg(channel_name, f"üîá @{username} wy≈ÇƒÖczy≈Ç automatyczne dziƒôkowanie za suby.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, brak uprawnie≈Ñ do wy≈ÇƒÖczenia sub√≥w.")
            return

        elif message == "!subson":
            if username in self.trusted_users:
                if not os.getenv('TWITCH_CLIENT_ID') or not os.getenv('TWITCH_ACCESS_TOKEN'):
                    connection.privmsg(channel_name, f"‚ùå @{username}, brak konfiguracji Twitch API. Zobacz TWITCH_API_SETUP.md")
                    return
                    
                self.sub_thanks_enabled = True
                if not self.check_subscribers_thread or not self.check_subscribers_thread.is_alive():
                    self.start_subscription_checker()
                connection.privmsg(channel_name, f"üåü @{username} w≈ÇƒÖczy≈Ç automatyczne dziƒôkowanie za suby.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, brak uprawnie≈Ñ do w≈ÇƒÖczenia sub√≥w.")
            return

        elif message == "!subs":
            if not os.getenv('TWITCH_CLIENT_ID') or not os.getenv('TWITCH_ACCESS_TOKEN'):
                connection.privmsg(channel_name, f"‚ùå @{username}, brak konfiguracji Twitch API.")
                return
                
            try:
                subscribers = self.get_twitch_subscribers()
                if subscribers:
                    sub_count = len(subscribers)
                    if sub_count > 0:
                        # Poka≈º tylko pierwszych 10 subskrybent√≥w, ≈ºeby nie spamowaƒá chatu
                        display_subs = subscribers[:10]
                        subs_text = ", ".join(display_subs)
                        if sub_count > 10:
                            connection.privmsg(channel_name, f"üåü Subskrybenci ({sub_count}): {subs_text} i {sub_count - 10} wiƒôcej...")
                        else:
                            connection.privmsg(channel_name, f"üåü Subskrybenci ({sub_count}): {subs_text}")
                    else:
                        connection.privmsg(channel_name, "üìä Brak subskrybent√≥w.")
                else:
                    connection.privmsg(channel_name, f"‚ùå @{username}, nie uda≈Ço siƒô pobraƒá listy subskrybent√≥w.")
            except Exception as e:
                safe_print(f"‚ùå B≈ÇƒÖd komendy !subs: {e}")
                connection.privmsg(channel_name, f"‚ùå @{username}, b≈ÇƒÖd przy pobieraniu subskrybent√≥w.")
            return

        # === KOMENDY MODYFIKACJI KANA≈ÅU ===
        elif message.startswith("!settitle "):
            if username in self.trusted_users or username.lower() == "kranik1606":
                new_title = message[len("!settitle "):].strip()
                if new_title:
                    connection.privmsg(channel_name, f"üìù @{username}, zmieniam tytu≈Ç streama...")
                    success = self.modify_channel_info(title=new_title)
                    if success:
                        connection.privmsg(channel_name, f"‚úÖ @{username}, tytu≈Ç streama zosta≈Ç zmieniony na: {new_title}")
                    else:
                        connection.privmsg(channel_name, f"‚ùå @{username}, nie uda≈Ço siƒô zmieniƒá tytu≈Çu streama.")
                else:
                    connection.privmsg(channel_name, f"@{username}, u≈ºyj: !settitle <nowy tytu≈Ç>")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do zmiany tytu≈Çu.")
            return

        elif message.startswith("!setgame "):
            if username in self.trusted_users or username.lower() == "kranik1606":
                new_game = message[len("!setgame "):].strip()
                if new_game:
                    connection.privmsg(channel_name, f"üéÆ @{username}, zmieniam kategoriƒô streama...")
                    success = self.modify_channel_info(game_name=new_game)
                    if success:
                        connection.privmsg(channel_name, f"‚úÖ @{username}, kategoria streama zosta≈Ça zmieniona na: {new_game}")
                    else:
                        connection.privmsg(channel_name, f"‚ùå @{username}, nie uda≈Ço siƒô zmieniƒá kategorii streama.")
                else:
                    connection.privmsg(channel_name, f"@{username}, u≈ºyj: !setgame <nazwa gry>")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do zmiany kategorii.")
            return

        elif message.startswith("!setstream "):
            if username in self.trusted_users or username.lower() == "kranik1606":
                # Format: !setstream "tytu≈Ç" "gra"
                parts = message[len("!setstream "):].strip()
                
                # Parsuj argumenty w cudzys≈Çowach
                import re
                matches = re.findall(r'"([^"]*)"', parts)
                
                if len(matches) >= 2:
                    new_title = matches[0]
                    new_game = matches[1]
                    connection.privmsg(channel_name, f"üîÑ @{username}, zmieniam tytu≈Ç i kategoriƒô streama...")
                    success = self.modify_channel_info(title=new_title, game_name=new_game)
                    if success:
                        connection.privmsg(channel_name, f"‚úÖ @{username}, stream zaktualizowany!")
                        connection.privmsg(channel_name, f"üìù Tytu≈Ç: {new_title}")
                        connection.privmsg(channel_name, f"üéÆ Kategoria: {new_game}")
                    else:
                        connection.privmsg(channel_name, f"‚ùå @{username}, nie uda≈Ço siƒô zaktualizowaƒá streama.")
                else:
                    connection.privmsg(channel_name, f'@{username}, u≈ºyj: !setstream "tytu≈Ç" "gra"')
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do zmiany streama.")
            return

        elif message == "!motywacja":
            quote = random.choice(MOTYWACYJNE_CYTATY)
            connection.privmsg(channel_name, f"üí™ {quote}")

        elif message.startswith("!clear_discord "):
            # Sprawd≈∫ uprawnienia - tylko w≈Ça≈õciciel
            is_owner = username.lower() == "kranik1606"
            
            if not is_owner:
                connection.privmsg(channel_name, f"‚ùå @{username}, tylko w≈Ça≈õciciel kana≈Çu mo≈ºe czy≈õciƒá kana≈Çy Discord.")
                return
            
            parts = message.split()
            if len(parts) >= 2:
                channel_id = parts[1]
                
                # Sprawd≈∫ czy Discord bot jest skonfigurowany
                if not self.discord.bot_enabled:
                    connection.privmsg(channel_name, f"‚ùå @{username}, Discord bot nie jest skonfigurowany.")
                    return
                
                connection.privmsg(channel_name, f"üßπ @{username}, rozpoczynam czyszczenie kana≈Çu Discord (ID: {channel_id})...")
                
                # Uruchom czyszczenie w osobnym wƒÖtku
                def clear_channel_thread():
                    try:
                        import asyncio
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                        success = loop.run_until_complete(
                            self.discord.clear_discord_channel(channel_id, username)
                        )
                        loop.close()
                        
                        if success:
                            self.connection.privmsg(channel_name, f"‚úÖ @{username}, czyszczenie kana≈Çu Discord zako≈Ñczone!")
                        else:
                            self.connection.privmsg(channel_name, f"‚ùå @{username}, wystƒÖpi≈Ç b≈ÇƒÖd podczas czyszczenia kana≈Çu.")
                    except Exception as e:
                        safe_print(f"‚ùå B≈ÇƒÖd czyszczenia kana≈Çu Discord: {e}")
                        self.connection.privmsg(channel_name, f"‚ùå @{username}, b≈ÇƒÖd podczas czyszczenia: {str(e)}")
                
                threading.Thread(target=clear_channel_thread, daemon=True).start()
            else:
                connection.privmsg(channel_name, f"@{username}, u≈ºyj: !clear_discord <channel_id>")
            return

        elif message == "!clear_points":
            if username in self.trusted_users:
                connection.privmsg(channel_name, f"üßπ @{username}, rozpoczynam czyszczenie punkt√≥w u≈ºytkownikom bez follow...")
                cleared_count = self.clear_non_followers_points()
                connection.privmsg(channel_name, f"‚úÖ @{username}, wyczyszczono punkty {cleared_count} u≈ºytkownikom.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do czyszczenia punkt√≥w.")

        elif message.startswith("!checkfollow "):
            if username in self.trusted_users or username.lower() == "kranik1606":
                target_user = message[len("!checkfollow "):].strip().lstrip('@').lower()
                if target_user:
                    is_follower = self.is_follower(target_user)
                    status = "‚úÖ TAK" if is_follower else "‚ùå NIE"
                    connection.privmsg(channel_name, f"üîç @{username}, u≈ºytkownik {target_user} ma follow: {status}")
                else:
                    connection.privmsg(channel_name, f"@{username}, u≈ºyj: !checkfollow <username>")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do sprawdzania follow√≥w.")

        elif message.startswith("!rc "):
            # Komenda rekomendacji - tylko dla w≈Ça≈õciciela i moderator√≥w
            if username in self.trusted_users or username.lower() == "kranik1606":
                target_user = message[len("!rc "):].strip().lstrip('@')
                if target_user:
                    # Link do profilu na Twitchu
                    profile_link = f"https://twitch.tv/{target_user}"
                    
                    # Lista fajnych opis√≥w zachƒôcajƒÖcych do sprawdzenia profilu z linkiem
                    recommend_messages = [
                        f"üåü Hej czat! Sprawd≈∫cie profil {target_user} na Twitchu! üî• Warto rzuciƒá okiem na jego content! üëÄ {profile_link}",
                        f"üíé {target_user} ma naprawdƒô ciekawy profil! Polecam zajrzeƒá i mo≈ºe daƒá follow! üöÄ‚ú® {profile_link}",
                        f"üéØ Czat, koniecznie sprawd≈∫cie {target_user}! Jego tre≈õci sƒÖ naprawdƒô warte uwagi! üíúüî• {profile_link}",
                        f"‚≠ê {target_user} robi ≈õwietne rzeczy na Twitchu! Zdecydowanie warto go obserwowaƒá! üéÆüí´ {profile_link}",
                        f"üöÄ Polecam wszystkim profil {target_user}! Naprawdƒô fajny content czeka na Was! üåüüëë {profile_link}",
                        f"üí´ {target_user} zas≈Çuguje na wiƒôcej uwagi! Sprawd≈∫cie jego kana≈Ç - nie po≈ºa≈Çujecie! üî•üíú {profile_link}",
                        f"üéä Hej spo≈Çeczno≈õƒá! {target_user} ma super profil na Twitchu! Dajcie mu szansƒô! ‚ú®üéØ {profile_link}"
                    ]
                    
                    recommendation = random.choice(recommend_messages)
                    connection.privmsg(channel_name, recommendation)
                    safe_print(f"üì¢ {username} poleci≈Ç profil: {target_user} ({profile_link})")
                else:
                    connection.privmsg(channel_name, f"@{username}, u≈ºyj: !rc @username")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do polecania profili.")

        elif message == "!update_shop":
            if username in self.trusted_users or username.lower() == "kranik1606":
                connection.privmsg(channel_name, f"üõí @{username}, wymuszam aktualizacjƒô sklepu Discord...")
                try:
                    self.shop.force_update_shop_post()
                    connection.privmsg(channel_name, f"‚úÖ @{username}, sklep Discord zosta≈Ç zaktualizowany!")
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd aktualizacji sklepu: {e}")
                    connection.privmsg(channel_name, f"‚ùå @{username}, b≈ÇƒÖd podczas aktualizacji sklepu.")
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do aktualizacji sklepu.")



        elif message == "!shutdown":
            if username in self.trusted_users:
                connection.privmsg(channel_name, "Robocik siƒô odmeldowuje! ü§ñüëã")
                self.connection.quit("Shutdown by command")
                sys.exit(0)
            else:
                connection.privmsg(channel_name, f"‚ùå @{username}, nie masz uprawnie≈Ñ do wy≈ÇƒÖczenia bota.")

    # === METODY OBS≈ÅUGI FOLLOW√ìW ===
    def start_follow_checker(self):
        """Uruchamia wƒÖtek sprawdzajƒÖcy nowych follower√≥w"""
        def follow_checker_loop():
            # Pobierz poczƒÖtkowƒÖ listƒô follower√≥w
            initial_followers = self.get_twitch_followers()
            if initial_followers:
                self.last_followers = set(initial_followers)
                safe_print(f"üìä Za≈Çadowano {len(self.last_followers)} follower√≥w")
            
            while self.follow_thanks_enabled:
                try:
                    time.sleep(15)  # Sprawdzaj co 15 sekund
                    self.check_new_followers()
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd sprawdzania follow√≥w: {e}")
                    time.sleep(60)  # Czekaj d≈Çu≈ºej przy b≈Çƒôdzie

        self.check_followers_thread = threading.Thread(target=follow_checker_loop, daemon=True)
        self.check_followers_thread.start()
        safe_print(f"üîÑ Uruchomiono sprawdzanie follow√≥w")

    def check_new_followers(self):
        """Sprawdza nowych follower√≥w i dziƒôkuje im"""
        current_followers = self.get_twitch_followers()
        if not current_followers:
            return

        current_set = set(current_followers)
        new_followers = current_set - self.last_followers
        
        for follower in new_followers:
            self.thank_for_follow(follower)
            time.sleep(2)  # Odstƒôp miƒôdzy podziƒôkowaniami
        
        self.last_followers = current_set

    def get_twitch_followers(self):
        """Pobiera listƒô follower√≥w z Twitch API z paginacjƒÖ"""
        try:
            # U≈ºywamy Twitch Helix API
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}'
            }
            
            # Najpierw pobierz ID kana≈Çu
            user_url = f"https://api.twitch.tv/helix/users?login={CHANNEL.lstrip('#')}"
            user_response = requests.get(user_url, headers=headers)
            
            if user_response.status_code != 200:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania danych u≈ºytkownika: {user_response.status_code}")
                return None
                
            user_data = user_response.json()
            if not user_data.get('data'):
                safe_print(f"‚ùå Nie znaleziono danych u≈ºytkownika")
                return None
                
            broadcaster_id = user_data['data'][0]['id']
            
            # Pobierz wszystkich follower√≥w z paginacjƒÖ
            all_followers = []
            cursor = None
            
            while True:
                # Buduj URL z cursorem je≈õli istnieje
                followers_url = f"https://api.twitch.tv/helix/channels/followers?broadcaster_id={broadcaster_id}&first=100"
                if cursor:
                    followers_url += f"&after={cursor}"
                
                followers_response = requests.get(followers_url, headers=headers)
                
                if followers_response.status_code != 200:
                    safe_print(f"‚ùå B≈ÇƒÖd pobierania follower√≥w: {followers_response.status_code}")
                    return None
                    
                followers_data = followers_response.json()
                page_followers = [follower['user_name'].lower() for follower in followers_data.get('data', [])]
                all_followers.extend(page_followers)
                
                # Sprawd≈∫ czy sƒÖ kolejne strony
                pagination = followers_data.get('pagination', {})
                cursor = pagination.get('cursor')
                
                if not cursor:
                    break  # Brak kolejnych stron
                    
                # Dodaj ma≈Çe op√≥≈∫nienie miƒôdzy requestami
                time.sleep(0.1)
            
            safe_print(f"üìä Pobrano {len(all_followers)} follower√≥w (wszystkich)")
            return all_followers
            
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd API Twitch: {e}")
            return None

    def thank_for_follow(self, username):
        """Dziƒôkuje za follow"""
        if not self.follow_thanks_enabled:
            return
            
        try:
            message = random.choice(FOLLOW_THANKS_MESSAGES).format(username=username)
            channel_name = self.get_channel_name()
            self.connection.privmsg(channel_name, message)
            # Powiadomienie Discord o nowym followerze
            self.discord.notify_new_follower(username)
            safe_print(f"üíú Podziƒôkowano za follow: {username}")
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd dziƒôkowania za follow: {e}")

    # === METODY OBS≈ÅUGI SUBSKRYPCJI ===
    def start_subscription_checker(self):
        """Uruchamia wƒÖtek sprawdzajƒÖcy nowych subskrybent√≥w"""
        def subscription_checker_loop():
            # Pobierz poczƒÖtkowƒÖ listƒô subskrybent√≥w
            initial_subscribers = self.get_twitch_subscribers()
            if initial_subscribers:
                self.last_subscribers = set(initial_subscribers)
                safe_print(f"üìä Za≈Çadowano {len(self.last_subscribers)} subskrybent√≥w")
            
            while self.sub_thanks_enabled:
                try:
                    time.sleep(15)  # Sprawdzaj co 15 sekund
                    self.check_new_subscribers()
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd sprawdzania subskrypcji: {e}")
                    time.sleep(60)  # Czekaj d≈Çu≈ºej przy b≈Çƒôdzie

        self.check_subscribers_thread = threading.Thread(target=subscription_checker_loop, daemon=True)
        self.check_subscribers_thread.start()
        safe_print(f"üîÑ Uruchomiono sprawdzanie subskrypcji")

    def check_new_subscribers(self):
        """Sprawdza nowych subskrybent√≥w i dziƒôkuje im"""
        current_subscribers = self.get_twitch_subscribers()
        if not current_subscribers:
            return

        current_set = set(current_subscribers)
        new_subscribers = current_set - self.last_subscribers
        
        for subscriber in new_subscribers:
            self.thank_for_subscription(subscriber)
            time.sleep(2)  # Odstƒôp miƒôdzy podziƒôkowaniami
        
        self.last_subscribers = current_set

    def get_twitch_subscribers(self):
        """Pobiera listƒô subskrybent√≥w z Twitch API z paginacjƒÖ"""
        try:
            # U≈ºywamy Twitch Helix API
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}'
            }
            
            # Najpierw pobierz ID kana≈Çu
            user_url = f"https://api.twitch.tv/helix/users?login={CHANNEL.lstrip('#')}"
            user_response = requests.get(user_url, headers=headers)
            
            if user_response.status_code != 200:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania danych u≈ºytkownika: {user_response.status_code}")
                return None
                
            user_data = user_response.json()
            if not user_data.get('data'):
                safe_print(f"‚ùå Nie znaleziono danych u≈ºytkownika")
                return None
                
            broadcaster_id = user_data['data'][0]['id']
            
            # Pobierz wszystkich subskrybent√≥w z paginacjƒÖ
            all_subscribers = []
            cursor = None
            
            while True:
                # Buduj URL z cursorem je≈õli istnieje
                subscribers_url = f"https://api.twitch.tv/helix/subscriptions?broadcaster_id={broadcaster_id}&first=100"
                if cursor:
                    subscribers_url += f"&after={cursor}"
                
                subscribers_response = requests.get(subscribers_url, headers=headers)
                
                if subscribers_response.status_code != 200:
                    safe_print(f"‚ùå B≈ÇƒÖd pobierania subskrybent√≥w: {subscribers_response.status_code}")
                    return None
                    
                subscribers_data = subscribers_response.json()
                page_subscribers = [sub['user_name'].lower() for sub in subscribers_data.get('data', [])]
                all_subscribers.extend(page_subscribers)
                
                # Sprawd≈∫ czy sƒÖ kolejne strony
                pagination = subscribers_data.get('pagination', {})
                cursor = pagination.get('cursor')
                
                if not cursor:
                    break  # Brak kolejnych stron
                    
                # Dodaj ma≈Çe op√≥≈∫nienie miƒôdzy requestami
                time.sleep(0.1)
            
            safe_print(f"üìä Pobrano {len(all_subscribers)} subskrybent√≥w (wszystkich)")
            return all_subscribers
            
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd API Twitch (subskrypcje): {e}")
            return None

    def thank_for_subscription(self, username):
        """Dziƒôkuje za subskrypcjƒô"""
        if not self.sub_thanks_enabled:
            return
            
        try:
            message = random.choice(SUB_THANKS_MESSAGES).format(username=username)
            channel_name = self.get_channel_name()
            self.connection.privmsg(channel_name, message)
            # Powiadomienie Discord o nowym subskrybencie
            self.discord.notify_new_subscriber(username)
            safe_print(f"üåü Podziƒôkowano za sub: {username}")
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd dziƒôkowania za sub: {e}")

    # === METODY OBS≈ÅUGI UPRAWNIE≈É ===
    def update_permissions_on_startup(self):
        """Uruchamia pierwsze pobieranie uprawnie≈Ñ w osobnym wƒÖtku"""
        def permissions_updater():
            try:
                safe_print(f"üîÑ Pobieranie uprawnie≈Ñ z Twitch API...")
                self.fetch_moderators()
                self.fetch_vips()
                self.fetch_subscribers_for_permissions()
                self.update_permission_lists()
                safe_print(f"‚úÖ Uprawnienia zaktualizowane!")
                
                # Uruchom cykliczne od≈õwie≈ºanie co 5 minut
                while True:
                    time.sleep(300)  # 5 minut
                    try:
                        self.fetch_moderators()
                        self.fetch_vips()
                        self.fetch_subscribers_for_permissions()
                        self.update_permission_lists()
                        # Wyczy≈õƒá punkty u≈ºytkownikom bez follow
                        self.clear_non_followers_points()
                        safe_print(f"üîÑ Uprawnienia od≈õwie≈ºone")
                    except Exception as e:
                        safe_print(f"‚ùå B≈ÇƒÖd od≈õwie≈ºania uprawnie≈Ñ: {e}")
                        
            except Exception as e:
                safe_print(f"‚ùå B≈ÇƒÖd inicjalizacji uprawnie≈Ñ: {e}")
        
        permissions_thread = threading.Thread(target=permissions_updater, daemon=True)
        permissions_thread.start()

    def fetch_moderators(self):
        """Pobiera listƒô moderator√≥w z Twitch API"""
        try:
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}'
            }
            
            # Pobierz ID kana≈Çu
            user_url = f"https://api.twitch.tv/helix/users?login={CHANNEL.lstrip('#')}"
            user_response = requests.get(user_url, headers=headers)
            
            if user_response.status_code != 200:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania danych u≈ºytkownika dla moderator√≥w: {user_response.status_code}")
                return
                
            user_data = user_response.json()
            if not user_data.get('data'):
                safe_print(f"‚ùå Nie znaleziono danych u≈ºytkownika dla moderator√≥w")
                return
                
            broadcaster_id = user_data['data'][0]['id']
            
            # Pobierz moderator√≥w
            moderators_url = f"https://api.twitch.tv/helix/moderation/moderators?broadcaster_id={broadcaster_id}&first=100"
            moderators_response = requests.get(moderators_url, headers=headers)
            
            if moderators_response.status_code == 200:
                moderators_data = moderators_response.json()
                moderators = [mod['user_name'].lower() for mod in moderators_data.get('data', [])]
                self.moderators = set(moderators)
                safe_print(f"üìã Pobrano {len(self.moderators)} moderator√≥w")
            else:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania moderator√≥w: {moderators_response.status_code}")
                
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd API moderator√≥w: {e}")

    def fetch_vips(self):
        """Pobiera listƒô VIP-√≥w z Twitch API"""
        try:
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}'
            }
            
            # Pobierz ID kana≈Çu
            user_url = f"https://api.twitch.tv/helix/users?login={CHANNEL.lstrip('#')}"
            user_response = requests.get(user_url, headers=headers)
            
            if user_response.status_code != 200:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania danych u≈ºytkownika dla VIP: {user_response.status_code}")
                return
                
            user_data = user_response.json()
            if not user_data.get('data'):
                safe_print(f"‚ùå Nie znaleziono danych u≈ºytkownika dla VIP")
                return
                
            broadcaster_id = user_data['data'][0]['id']
            
            # Pobierz VIP-√≥w
            vips_url = f"https://api.twitch.tv/helix/channels/vips?broadcaster_id={broadcaster_id}&first=100"
            vips_response = requests.get(vips_url, headers=headers)
            
            if vips_response.status_code == 200:
                vips_data = vips_response.json()
                vips = [vip['user_name'].lower() for vip in vips_data.get('data', [])]
                self.vips = set(vips)
                safe_print(f"‚≠ê Pobrano {len(self.vips)} VIP-√≥w")
            else:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania VIP-√≥w: {vips_response.status_code}")
                
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd API VIP-√≥w: {e}")

    def fetch_subscribers_for_permissions(self):
        """Pobiera listƒô subskrybent√≥w dla uprawnie≈Ñ (u≈ºywa istniejƒÖcƒÖ funkcjƒô)"""
        try:
            subscribers = self.get_twitch_subscribers()
            if subscribers:
                self.subscribers = set(subscribers)
                safe_print(f"üåü Pobrano {len(self.subscribers)} subskrybent√≥w dla uprawnie≈Ñ")
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd pobierania subskrybent√≥w dla uprawnie≈Ñ: {e}")

    def update_permission_lists(self):
        """Aktualizuje wszystkie listy uprawnie≈Ñ na podstawie pobranych danych"""
        # Trusted users = moderatorzy + VIP + w≈Ça≈õciciel
        self.trusted_users = self.moderators | self.vips | {"kranik1606"}
        
        # Subs no limit = subskrybenci + VIP + w≈Ça≈õciciel  
        self.subs_no_limit = self.subscribers | self.vips | {"kranik1606"}
        
        # Allowed skip = moderatorzy + VIP + w≈Ça≈õciciel
        self.allowed_skip = self.moderators | self.vips | {"kranik1606"}
        
        safe_print(f"üîß Zaktualizowano uprawnienia:")
        safe_print(f"   üëë Trusted users: {len(self.trusted_users)}")
        safe_print(f"   üéµ Subs no limit: {len(self.subs_no_limit)}")
        safe_print(f"   ‚è≠Ô∏è Allowed skip: {len(self.allowed_skip)}")

    def is_follower(self, username):
        """Sprawdza czy u≈ºytkownik jest followerem"""
        return username.lower() in self.last_followers or username.lower() == "kranik1606"

    def clear_non_followers_points(self):
        """Czy≈õci punkty u≈ºytkownikom, kt√≥rzy nie sƒÖ followerami"""
        try:
            # Pobierz wszystkich u≈ºytkownik√≥w z bazy danych
            all_users = self.db.get_all_users_with_points()
            cleared_count = 0
            
            for user in all_users:
                username = user[0]  # Pierwsza kolumna to username
                current_points = user[1]  # Druga kolumna to points
                
                # Sprawd≈∫ czy u≈ºytkownik jest followerem (pomijaj w≈Ça≈õciciela)
                if not self.is_follower(username) and username.lower() != "kranik1606":
                    if current_points > 0:
                        # Wyczy≈õƒá punkty
                        self.db.set_user_points(username, 0)
                        cleared_count += 1
                        safe_print(f"üßπ Wyczyszczono punkty u≈ºytkownika: {username} ({current_points} pkt)")
            
            safe_print(f"‚úÖ Wyczyszczono punkty {cleared_count} u≈ºytkownikom bez follow")
            return cleared_count
            
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd czyszczenia punkt√≥w: {e}")
            return 0

    def get_channel_info(self, username):
        """Pobiera informacje o kanale z Twitch API (tytu≈Ç i grƒô)"""
        try:
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}'
            }
            
            # Pobierz ID u≈ºytkownika
            user_url = f"https://api.twitch.tv/helix/users?login={username}"
            user_response = requests.get(user_url, headers=headers)
            
            if user_response.status_code != 200:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania danych u≈ºytkownika {username}: {user_response.status_code}")
                return None
                
            user_data = user_response.json()
            if not user_data.get('data'):
                safe_print(f"‚ùå Nie znaleziono u≈ºytkownika {username}")
                return None
                
            user_id = user_data['data'][0]['id']
            
            # Pobierz informacje o kanale
            channel_url = f"https://api.twitch.tv/helix/channels?broadcaster_id={user_id}"
            channel_response = requests.get(channel_url, headers=headers)
            
            if channel_response.status_code == 200:
                channel_data = channel_response.json()
                if channel_data.get('data'):
                    channel_info = channel_data['data'][0]
                    return {
                        'game_name': channel_info.get('game_name', 'Nieznana gra'),
                        'title': channel_info.get('title', 'Brak tytu≈Çu')
                    }
            else:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania informacji o kanale {username}: {channel_response.status_code}")
                return None
                
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd API kana≈Çu dla {username}: {e}")
            return None

    def modify_channel_info(self, title=None, game_name=None):
        """Modyfikuje informacje o kanale (tytu≈Ç i/lub grƒô)"""
        try:
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}',
                'Content-Type': 'application/json'
            }
            
            # Pobierz ID u≈ºytkownika
            user_url = f"https://api.twitch.tv/helix/users?login={CHANNEL.lstrip('#')}"
            user_response = requests.get(user_url, headers=headers)
            
            if user_response.status_code != 200:
                safe_print(f"‚ùå B≈ÇƒÖd pobierania danych u≈ºytkownika: {user_response.status_code}")
                return False
                
            user_data = user_response.json()
            if not user_data.get('data'):
                safe_print(f"‚ùå Nie znaleziono u≈ºytkownika")
                return False
                
            user_id = user_data['data'][0]['id']
            
            # Przygotuj dane do modyfikacji
            modify_data = {}
            if title is not None:
                modify_data['title'] = title
            if game_name is not None:
                # Znajd≈∫ ID gry
                game_id = self.get_game_id(game_name)
                if game_id:
                    modify_data['game_id'] = game_id
                else:
                    safe_print(f"‚ùå Nie znaleziono gry: {game_name}")
                    return False
            
            if not modify_data:
                safe_print(f"‚ùå Brak danych do modyfikacji")
                return False
            
            # Modyfikuj kana≈Ç
            channel_url = f"https://api.twitch.tv/helix/channels?broadcaster_id={user_id}"
            response = requests.patch(channel_url, headers=headers, json=modify_data)
            
            if response.status_code == 204:
                safe_print(f"‚úÖ Pomy≈õlnie zaktualizowano kana≈Ç")
                if title:
                    safe_print(f"üìù Nowy tytu≈Ç: {title}")
                if game_name:
                    safe_print(f"üéÆ Nowa gra: {game_name}")
                return True
            else:
                safe_print(f"‚ùå B≈ÇƒÖd modyfikacji kana≈Çu: {response.status_code}")
                safe_print(f"‚ùå Odpowied≈∫: {response.text}")
                return False
                
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd modyfikacji kana≈Çu: {e}")
            return False

    def get_game_id(self, game_name):
        """Pobiera ID gry na podstawie nazwy"""
        try:
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}'
            }
            
            # Szukaj gry
            game_url = f"https://api.twitch.tv/helix/games?name={requests.utils.quote(game_name)}"
            response = requests.get(game_url, headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                if data.get('data'):
                    return data['data'][0]['id']
            
            safe_print(f"‚ùå Nie znaleziono gry: {game_name}")
            return None
            
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd pobierania ID gry: {e}")
            return None

    def on_usernotice(self, connection, event):
        """Obs≈Çuguje USERNOTICE wiadomo≈õci (rajdy, suby, etc.)"""
        try:
            # Parsuj tagi z wiadomo≈õci
            tags = {}
            if hasattr(event, 'tags'):
                for tag in event.tags:
                    if '=' in tag:
                        key, value = tag.split('=', 1)
                        tags[key] = value
            
            # Sprawd≈∫ czy to rajd
            msg_id = tags.get('msg-id', '')
            if msg_id == 'raid':
                raider_name = tags.get('msg-param-displayName', tags.get('display-name', 'Nieznany'))
                viewer_count = tags.get('msg-param-viewerCount', '0')
                
                safe_print(f"üöÄ Wykryto rajd od {raider_name} z {viewer_count} widzami!")
                
                # Pobierz informacje o kanale rajdera
                channel_info = self.get_channel_info(raider_name.lower())
                
                # Przygotuj wiadomo≈õƒá o rajdzie
                raid_message = f"üöÄ RAJD! {raider_name} zrajdowa≈Ç nas z {viewer_count} widzami! "
                raid_message += f"Koniecznie sprawd≈∫cie jego kana≈Ç: twitch.tv/{raider_name.lower()} "
                
                if channel_info and channel_info['game_name'] != 'Nieznana gra':
                    raid_message += f"- ostatnio gra≈Ç w: {channel_info['game_name']} üéÆ"
                else:
                    raid_message += "üéÆ"
                
                # Wy≈õlij wiadomo≈õƒá na chat
                connection.privmsg(channel_name, raid_message)
                
                # Dodatkowa wiadomo≈õƒá z polecajkƒÖ
                recommendation = f"üíú Polecam gorƒÖco kana≈Ç {raider_name}! Warto go obserwowaƒá! üåü"
                connection.privmsg(channel_name, recommendation)
                
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd obs≈Çugi USERNOTICE: {e}")

    def start_playback(self):
        try:
            devices = self.sp.devices()
            if devices['devices']:
                device_id = devices['devices'][0]['id']
                self.sp.start_playback(device_id=device_id)
                return True
            else:
                safe_print(f"Brak aktywnych urzƒÖdze≈Ñ Spotify.")
                return False
        except Exception as e:
            safe_print(f"Spotify playback error:", e)
            return False

    def start_reminder(self):
        def reminder_loop():
            # Op√≥≈∫nienie pierwszego przypomnienia o 15 sekund
            time.sleep(15)
            
            while True:
                channel_name = self.get_channel_name()
                self.connection.privmsg(channel_name, ZBIORKA_MSG)
                time.sleep(15)
                self.connection.privmsg(channel_name, FOLLOW_MSG)
                time.sleep(600)
                self.connection.privmsg(channel_name, DISCORD_MSG)
                time.sleep(900)
                self.connection.privmsg(channel_name, PRIME_MSG)
                time.sleep(0)
                self.connection.privmsg(channel_name, BITS_MSG)
                time.sleep(1800)

        thread = threading.Thread(target=reminder_loop, daemon=True)
        thread.start()

    # === MONITOROWANIE STATUSU STREAMA ===
    def start_stream_monitor(self):
        """Uruchamia monitorowanie statusu streama"""
        def stream_monitor_loop():
            last_status = None
            first_check = True
            while True:
                try:
                    current_status = self.check_stream_status()
                    safe_print(f"üì∫ Status streama: {current_status} (poprzedni: {last_status}, pierwszy: {first_check})")
                    
                    if current_status != last_status:
                        if current_status:
                            # Stream siƒô rozpoczƒÖ≈Ç
                            safe_print(f"üî¥ Wykryto rozpoczƒôcie streama!")
                            channel_info = self.get_channel_info(CHANNEL.lstrip('#'))
                            title = channel_info.get('title', '') if channel_info else ''
                            game = channel_info.get('game_name', '') if channel_info else ''
                            self.discord.notify_stream_status(True, title, game)
                            safe_print(f"üî¥ Stream LIVE - powiadomienie Discord wys≈Çane")
                        elif not first_check:
                            # Stream siƒô zako≈Ñczy≈Ç (ale nie przy pierwszym sprawdzeniu)
                            safe_print(f"‚ö´ Wykryto zako≈Ñczenie streama!")
                            self.discord.notify_stream_status(False)
                            safe_print(f"‚ö´ Stream OFFLINE - powiadomienie Discord wys≈Çane")
                        else:
                            safe_print(f"‚ö´ Stream offline przy pierwszym sprawdzeniu - pomijam powiadomienie")
                        last_status = current_status
                        first_check = False
                    time.sleep(60)  # Sprawdzaj co minutƒô
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd monitorowania streama: {e}")
                    time.sleep(60)
        
        monitor_thread = threading.Thread(target=stream_monitor_loop, daemon=True)
        monitor_thread.start()
        safe_print(f"üì∫ Monitor statusu streama uruchomiony")

    def check_stream_status(self):
        """Sprawdza czy stream jest live"""
        try:
            headers = {
                'Client-ID': os.getenv('TWITCH_CLIENT_ID'),
                'Authorization': f'Bearer {os.getenv("TWITCH_ACCESS_TOKEN")}'
            }
            
            # Sprawd≈∫ status streama
            stream_url = f"https://api.twitch.tv/helix/streams?user_login={CHANNEL.lstrip('#')}"
            response = requests.get(stream_url, headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                is_live = len(data.get('data', [])) > 0
                safe_print(f"üîç API Twitch: kana≈Ç {CHANNEL.lstrip('#')} - {'LIVE' if is_live else 'OFFLINE'}")
                return is_live  # True je≈õli stream jest live
            else:
                safe_print(f"‚ùå B≈ÇƒÖd sprawdzania statusu streama: {response.status_code}")
                return None
                
        except Exception as e:
            safe_print(f"‚ùå B≈ÇƒÖd API statusu streama: {e}")
            return None

    def start_daily_stats(self):
        """Uruchamia wysy≈Çanie dziennych statystyk Discord"""
        def daily_stats_loop():
            while True:
                try:
                    # Czekaj do 20:00 ka≈ºdego dnia
                    now = datetime.now()
                    target_time = now.replace(hour=20, minute=0, second=0, microsecond=0)
                    
                    # Je≈õli ju≈º minƒô≈Ça 20:00 dzisiaj, ustaw na jutro
                    if now >= target_time:
                        target_time += timedelta(days=1)
                    
                    # Oblicz czas do czekania
                    wait_seconds = (target_time - now).total_seconds()
                    safe_print(f"üìä Nastƒôpne statystyki Discord o {target_time.strftime('%Y-%m-%d %H:%M')}")
                    
                    time.sleep(wait_seconds)
                    
                    # Wy≈õlij statystyki
                    self.discord.send_daily_stats()
                    safe_print(f"üìä Dzienne statystyki Discord wys≈Çane")
                    
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd wysy≈Çania dziennych statystyk: {e}")
                    time.sleep(3600)  # Spr√≥buj ponownie za godzinƒô
        
        stats_thread = threading.Thread(target=daily_stats_loop, daemon=True)
        stats_thread.start()
        safe_print(f"üìä Harmonogram dziennych statystyk Discord uruchomiony")

    def start_quiz_timeout_checker(self):
        """Uruchamia sprawdzanie timeout quizu co 5 sekund"""
        def quiz_timeout_loop():
            while True:
                try:
                    quiz_timeout_msg = self.games.check_quiz_timeout()
                    if quiz_timeout_msg:
                        channel_name = self.get_channel_name()
                        self.connection.privmsg(channel_name, quiz_timeout_msg)
                    time.sleep(5)  # Sprawdzaj co 5 sekund
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd sprawdzania timeout quizu: {e}")
                    time.sleep(5)
        
        quiz_thread = threading.Thread(target=quiz_timeout_loop, daemon=True)
        quiz_thread.start()
        safe_print(f"‚ùì Monitor timeout quizu uruchomiony")

    def start_leaderboard_updater(self):
        """Uruchamia automatyczne sprawdzanie zmian w rankingu Discord co 30 minut"""
        def leaderboard_updater_loop():
            # Pierwsze uruchomienie po 60 sekundach
            time.sleep(60)
            
            while True:
                try:
                    safe_print(f"üèÜ Sprawdzam zmiany w rankingu...")
                    self.discord.update_leaderboard_if_changed(self.db)
                    
                    # Sprawdzaj co 30 minut
                    time.sleep(1800)
                    
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd sprawdzania rankingu Discord: {e}")
                    time.sleep(1800)  # Spr√≥buj ponownie za 30 minut
        
        leaderboard_thread = threading.Thread(target=leaderboard_updater_loop, daemon=True)
        leaderboard_thread.start()
        safe_print(f"üèÜ Automatyczne sprawdzanie zmian w rankingu Discord uruchomione")

    def start_shop_monitor(self):
        """Uruchamia monitorowanie zmian w sklepie i automatyczne aktualizacje Discord"""
        def shop_monitor_loop():
            # Pierwsze uruchomienie po 30 sekundach
            time.sleep(30)
            
            while True:
                try:
                    safe_print(f"üõí Sprawdzam zmiany w sklepie...")
                    self.shop.update_shop_post_if_changed()
                    
                    # Sprawdzaj co 5 minut
                    time.sleep(300)
                    
                except Exception as e:
                    safe_print(f"‚ùå B≈ÇƒÖd monitorowania sklepu: {e}")
                    time.sleep(300)  # Spr√≥buj ponownie za 5 minut
        
        shop_thread = threading.Thread(target=shop_monitor_loop, daemon=True)
        shop_thread.start()
        safe_print(f"üõí Monitor zmian w sklepie uruchomiony")

    def run(self):
        self.reactor.process_forever()

if __name__ == "__main__":
    bot = TwitchBot()
    safe_print(f"Bot wystartowa≈Ç!")
    bot.run()
